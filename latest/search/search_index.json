{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"http4s-jdk-http-client"},{"location":"/index.html#http4s-jdk-http-client","text":"","title":"http4s-jdk-http-client"},{"location":"/index.html#http-client","text":"http4s-jdk-http-client contains a http4s-client implementation based on the java.net.http.HttpClient introduced in Java 11.","title":"HTTP client"},{"location":"/index.html#installation","text":"To use http4s-jdk-http-client in an existing SBT project, add the following dependency to your build.sbt:\nlibraryDependencies ++= Seq(\n  \"org.http4s\" %% \"http4s-jdk-http-client\" % \"0.6-26-d3da9d1-SNAPSHOT\"\n)","title":"Installation"},{"location":"/index.html#compatibility","text":"Requires Java 11 or greater Built for Scala 2.12, 2.13 and 3 Works with http4s-client-1.0.0-M30\nTLS 1.3 on Java 11 On Java 11, TLS 1.3 is disabled by default (when using JdkHttpClient.simple). This is a workaround for a spurious bug, see #200.","title":"Compatibility"},{"location":"/index.html#creating-the-client","text":"","title":"Creating the client"},{"location":"/index.html#simple","text":"A default JDK HTTP client can be created with a call to simple for any Async type, such as cats.effect.IO:\nimport cats.effect.{IO, Resource}\nimport org.http4s.client.Client\nimport org.http4s.jdkhttpclient.JdkHttpClient\n\n// Here, we import the global runtime.\n// It comes for free with `cats.effect.IOApp`:\nimport cats.effect.unsafe.implicits.global\n\nval client: Resource[IO, Client[IO]] = JdkHttpClient.simple[IO]","title":"Simple"},{"location":"/index.html#custom-clients","text":"A JDK HTTP client can be passed to JdkHttpClient.apply for use as an http4s-client backend. It is a good idea to create the HttpClient in an effect, as it creates a default executor and SSL context:\nimport java.net.{InetSocketAddress, ProxySelector}\nimport java.net.http.HttpClient\n\nval client0: Resource[IO, Client[IO]] = Resource.eval(IO {\n  HttpClient.newBuilder()\n    .version(HttpClient.Version.HTTP_2)\n    .proxy(ProxySelector.of(new InetSocketAddress(\"www-proxy\", 8080)))\n    .build()\n}).flatMap(JdkHttpClient(_))","title":"Custom clients"},{"location":"/index.html#sharing","text":"The client instance contains shared resources such as a connection pool, and should be passed as an argument to code that uses it:\nimport cats.effect._\nimport cats.implicits._\nimport org.http4s._\nimport org.http4s.implicits._\n  \ndef fetchStatus[F[_]](c: Client[F], uri: Uri): F[Status] =\n  c.status(Request[F](Method.GET, uri = uri))\n\nclient\n  .use(c => fetchStatus(c, uri\"https://http4s.org/\"))\n  .unsafeRunSync()\n// res1: Status = Status(200)\nFailure to share Contrast with this alternate definition of fetchStatus, which would create a new HttpClient instance on every invocation: def fetchStatusInefficiently[F[_]: Async](uri: Uri): F[Status] =\n  JdkHttpClient.simple[F].use(_.status(Request[F](Method.GET, uri = uri)))","title":"Sharing"},{"location":"/index.html#restricted-headers","text":"The underlying HttpClient may disallow certain request headers like Host or Content-Length to be set directly by the user. Therefore, you can pass a set of ignored headers to JdkHttpClient.apply. By default, the set of restricted headers of OpenJDK 11 is used.\nIn OpenJDK 12+, there are less restricted headers by default, and you can disable the restriction for certain headers by passing -Djdk.httpclient.allowRestrictedHeaders=host,content-length etc. to java.","title":"Restricted headers"},{"location":"/index.html#further-reading","text":"For more details on the http4s-client, please see the core client documentation.","title":"Further reading"},{"location":"/index.html#websocket-client","text":"This package also contains a functional websocket client. Please note that the API may change in the future.","title":"Websocket client"},{"location":"/index.html#creation","text":"A WSClient is created using an HttpClient as above. It is encouraged to use the same HttpClient to construct a Client[F] and a WSClient[F].\nimport org.http4s.jdkhttpclient._\n\nval (http, webSocket) =\n  Resource.eval(IO(HttpClient.newHttpClient()))\n    .flatMap { httpClient =>\n      (JdkHttpClient[IO](httpClient), JdkWSClient[IO](httpClient)).tupled\n    }\n    // in almost all cases, it is better to call `use` instead\n    .allocated.map(_._1).unsafeRunSync()\n// http: Client[IO] = org.http4s.client.Client$$anon$1@f3a8b04\n// webSocket: WSClient[IO] = org.http4s.jdkhttpclient.WSClient$$anon$1@55439f28\nIf you do not need an HTTP client, you can also call JdkWSClient.simple[IO] as above.","title":"Creation"},{"location":"/index.html#overview","text":"We have the following websocket frame hierarchy:\nWSFrame WSControlFrame WSFrame.Close WSFrame.Ping WSFrame.Pong WSDataFrame WSFrame.Text WSFrame.Binary\nThere are two connection modes: “low-level” and “high-level”. Both manage the lifetime of a websocket connection via a Resource. In the low-level mode, you can send and have to receive arbitrary WSFrames. The high-level mode does the following things for you:\nHides the control frames (you can still send Ping and Close frames). Responds to Ping frames with Pongs and echoes Close frames (the received Close frame is exposed as a Deferred). In fact, this currently also the case for the “low-level” mode, but this will change when other websocket backends are added. Groups the data frames by their last attribute.","title":"Overview"},{"location":"/index.html#usage-example","text":"We use the “high-level” connection mode to build a simple websocket app.\nechoServer.use { echoUri =>\n  webSocket\n    .connectHighLevel(WSRequest(echoUri))\n    .use { conn =>\n      for {\n        // send a single Text frame\n        _ <- conn.send(WSFrame.Text(\"reality\"))\n        // send multiple frames (both Text and Binary are possible)\n        // \"faster\" than individual `send` calls\n        _ <- conn.sendMany(List(\n          WSFrame.Text(\"is often\"),\n          WSFrame.Text(\"disappointing.\")\n        ))\n        received <- conn\n          // a backpressured stream of incoming frames\n          .receiveStream\n          // we do not care about Binary frames (and will never receive any)\n          .collect { case WSFrame.Text(str, _) => str }\n          // send back the modified text\n          .evalTap(str => conn.send(WSFrame.Text(str.toUpperCase)))\n          .take(6)\n          .compile\n          .toList\n      } yield received.mkString(\" \")\n    } // the connection is closed here\n  }\n  .unsafeRunSync()\n// res2: String = \"reality is often disappointing. REALITY IS OFTEN DISAPPOINTING.\"\nFor an overview of all options and functions visit the scaladoc.","title":"Usage example"}]}